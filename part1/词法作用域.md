# 词法作用域

1. 词法作用域怎么理解？

   代码在书写时变量被声明的位置所确定的作用域规则。换句话说，词法作用域是静态确定的，它取决于代码的结构，而不是代码的运行时状态。

   

2. 如何理解 “遮蔽效应” ？

   作用域查找会在找到第一个匹配的标识符时停止。

   

3. 如何理解全局变量会自动成为全局对象的属性？

   ```javascript
   var a = 10;
   console.log(window.a); // 输出 10
   ```

   

4. eval(...)是如何做到欺骗词法作用域的，如下？

   ```javascript
   function foo(str, a){
   	eval(str);
   	console.log(b, a);
   }
   
   var b = 2;
   
   foo("var b = 3;", 1);
   ```

   **eval()会把var b = 3视为书写的时候就存在于那个位子**

   

5. 严格模式下第四题会有什么结果？

   严格模式会报错。

   

6. 使用with(..)去欺骗词法作用域时的结果和原理，如下？

   ```javascript
   function foo(obj){
   	with(obj){
   		a = 2;
       }
   }
   
   var o1 = {
       a: 3
   };
   
   var o2 = {
       b: 3
   };
   
   foo(o1);
   console.log(o1.a);
   
   foo(o2);
   console.log(o2.a);
   console.log(a);
   ```

   with通常会被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。用法：

   ```javascript
   var obj = {
       a: 1,
       b: 2,
       c: 3
   }
   
   obj.a = 2;
   obj.b = 3;
   obj.c = 4;
   
   with(obj){
   	a = 3;
       b = 4;
       c = 5;
   }
   ```

   所以问题的输出答案是：

   ```javascript
   2
   undefined
   2
   ```

   with相当于创建了一个新的作用域，但是新的块作用域没有a，所以a泄露到全局对象上。

   

7. 怎么理解with将一个对象处理为词法作用域？

   with可以将一个对象处理为词法作用域，只是会存在泄露的问题。

   

8. eval(..)和with(..)的两种欺骗词法作用域的方式的不同之处？

   前者是将一个或多个字符串通过演算修改，后者是一个对象的引用当作作用域处理。

   

9. eval(..)和with(..)使用时会降低代码性能，降低代码性能的原理是什么？

   导致引擎在编译时无法对作用域查找优化，从而降低代码运行速度。